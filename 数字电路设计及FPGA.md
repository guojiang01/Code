# 数字电路设计及FPGA

### 一门最好的语言就是在你的环境里已经使用的语言或者是客户要求使用的语言 

1. 同步时序电路：包含环路的环，它的输出直接反馈到输入，它们是时许电路而不是组合电路。组合逻辑没有环路和竞争。为了避免这些问题，设计师在路径中插入寄存器来断开环路。将电路转变成组合逻辑和寄存器的集合。寄存器包含系统的状态，这些状态仅仅在时钟到达时发生改变，所有说状态**同步于**时钟信号。如果时钟足够慢，使得在下一个时钟沿到达之前输入到寄存器的信号都可以稳定下来，那么所有的竞争都将被消除。

2. **同步时序电路**有一个时钟输入，它的上升沿表示时序电路状态转变发生的事件。我们经常使用术语*当前状态*和*下一个状态*来区分目前系统的状态和下一个时钟沿系统将要进入的状态。

3. 时序规范包括上界时间$t_{pcq}$和下界时间$t_{ccq}$ ，它是从时钟的上升沿知道**输出**改变的时间以及**建立**时间$t_{setup}$和**保持**时间$t_{hold}$,它表示当前**输入**必须相对于时钟的上升沿稳定。

4. **同步时序电路的组成**规则告诉我们，一个电路是同步时序电路，如果它由相互连接的电路元件构成，且需要满足一下条件。
   + 每一个电路元件是寄存器或者是组合电路
   + 至少有一个元件是寄存器
   + 所有寄存器都接收同一个时钟信号
   + 每个环路至少包含一个寄存器

5. 两种常见的同步时序电路成为**有限状态机**和**流水线**

6. 由电路图导出状态机
   + 检查电路，标明输入、输出和状态位
   + 写出下一个状态和输出表
   + 创建下一个状态和输出表
   + 删除不可达状态来简化下一个状态表
   + 给每个有效状态位组合指定状态名称
   + 用状态名称重写下一个状态和输出表
   + 画出状态转换图
   + 使用文字阐述有限状态机的功能

7. 有限状态机小结

   + 确定输入和输出
   + 画出状态转换图
   + 对于$Moore$型状态机：
     + 写出状态转换表
     + 写出输出表

   + 对于$Mealy$型状态机：
     + 写出组合的状态转换表和输出表

   + 选择状态编码——这个选择将影响硬件设计
   + 为下一个状态和输出逻辑写出布尔表达式
   + 画出电路草图

8. **动态约束**

   为了电路对输入正确采样，在时钟上升沿到来前，输入必须在*建立时间*(setup time) $t_{setup}$内保持稳定，在时钟上升沿后，输入必须保持至少*保持时间*（hold time）$t_{hold}$内保持稳定。建立时间和保持时间统称为电路的*孔径时间*，因为它是输入保持稳定状态的时间总和。

   **动态约束**是指同步时序电路的输入必须在时钟沿附近的建立和维持孔径时间内保持稳定

9. **建立时间约束** 

   $t_{pd}\leq T_c-(t_{pcp}+t_{setup})$ 制造商确定触发器时钟到$Q$的传播延迟$t_{pcq}$和建立时间$t_{setup}$.在圆括号内的项$t_{pd}+t_{setup}$称为*时序开销*。理想状态下，整个周期时间$T_c$都应用于组合逻辑中有用的计算，其传播延迟为$t_{pd}$。但是，触发器的时序开销占用了周期时间。上式称为*建立时间约束*或*最大延迟约束*，因为它取决于建立时间，并限制通过组合逻辑的最大延迟。
   
   + 解决问题的方法有两个：增加时钟周期或重新设计组合逻辑来缩短传播延迟

10. **保持时间约束**

    $t_{cd}\geq t_{hold}-t_{ccq}$ 称为*保持时间约束*或者*最小延迟约束*，因为它限制了通过组合逻辑的最小延迟。如果不能满足，则唯一的解决方法是重新设计电路以便增加组合逻辑的最小延迟。与建立约束不同，他们不能通过调整时钟周期来改正。

11. 数字系统设计人员的目标是：对于给定的异步输入，确保遇到的亚稳态电压的概率足够小。为了确保产生正确的逻辑电平，所有的异步输入必须经过*同步器* 。

    + 用2个触发器来建立同步器的简单方法。$F1$在$CLK$的上升沿对$D$进行采样，如果$D$在这个时刻发生改变，则输出$D2$将出现暂时的亚稳态。如果时钟周期足够长，则在周期结束前$D2$成为一个有效逻辑电平的概率很高。然后$F2$对$D2$进行采样，它现在是稳定的，将产生一个好的输出$Q$ ($F1$$F2$为$D$触发器)

    + 如果同步器的输出$Q$为亚稳态，那么这个同步器将*失效*。

    + 系统的可靠性通常由**平均失效间隔时间（MTBF）**度量。根据定义可以看出,**MTBF**是系统失效之间的平均时间。它是系统失效概率的倒数：

      **MTBF**=$\frac1{P(失效)/sec}$=$\frac{T_ce^{T_c-t_{setup}}}{NT_0}$ 

12. 系统的速度可以用延迟和通过系统的信息吞吐量来度量。**任务**定义为经过处理后能产生一组输出的一组输入。**延迟**是从开始到结束所需的时间。**吞吐量**是系统单位时间内产生的任务的数量

13. 与输出只取决于当前输入的组合逻辑电路相比，时许逻辑电路的输出取决于当前和先前的输入。换句话说，时许逻辑电路记忆先前的输入信息。这种记忆称为逻辑的状态
    + 时许逻辑电路很难分析，并用以产生设计错误，所以我们只关心小部分成熟的模块。需要掌握的最重要元器件就是触发器，它接收时钟和输入$D$，产生一个输出$Q$。触发器在时钟的上升沿将$D$复制到$Q$，其他时候保持$Q$原来的状态。共享一个公共时钟的触发器称为寄存器。触发器还可以接收复位和使能控制信号。
    + 虽然有多种形式的时许逻辑，但我们只考虑最容易设计的同步时许逻辑电路。同步时许逻辑电路包含由时钟驱动寄存器隔开的组合逻辑块。电路的状态存储在寄存器中，仅在时钟沿到达时进行更新。
    + 同步时许逻辑电路的时序规范包括时钟到$Q$的传播延迟$t_{pcq}$和最小延迟$t_{ccq}$，建立时间$t_{setup}$和保持时间$t_{hold}$。为了正确操作，它们的输入在孔径时间内必须稳定。孔径时间在时钟的上升沿之前启动建立时间，在时钟的上升沿之后结束保持时间。系统的最小延迟周期$T_c$等于通过组合逻辑块的传播延迟$t_{pd}$加上寄存器的$t_{pcq}+t_{setup}$。为了正确操作，通过寄存器和组合逻辑的最小延迟必须大于$t_{hold}$。与常见的误解相反，**保持时间不影响周期时间**

14. 锁存器：当时钟为$HIGH$时，$D$锁存器是透明的，允许数据从输入流向输出。当时钟为$LOW$时锁存器变为不透明的，保持原来的状态。不是所有的综合工具都能很好地支持锁存器。除非你知道工具支持锁存器，或者你有理由使用它们，否则，最好不使用他们而使用边沿触发器。$always\_latch$等同于$always @ (clk,d)$ ,它是$system\ verilog$中用来描述锁存器的首选风格. 

    $always\_comb$等同于$always\ @(a)$，但比$always@(a)$更好，因为它避免了在$always$语句中由于信号改名或添加信号所带来的错误。  

### 数字模块

1. **半加器**：半加器有两个输入$A$和$B$，两个输出$S$和$C_{out}$.$S$是$A$和$B$的和，$C_{out}$是进位
2. **全加器**：多了接收进位$C_{in}$ 
3. **进位传播加法器**：一个$N$位加法器将两个$N$位输入$(A、B)$和一位进位$C_{in}$相加，产生一个$N$位结果$S$和一个输出进位$C_{out}$。
   + 行波进位加法器：构造$N$位进位传播加法器的最简单方法就是把$N$个全加器串联起来。其中一级的$C_{out}$就是下一级的$C_{in}$。这是规模化和规整化的一个应用范例：全加器模块在一个更大的系统中被多次重用。行波进位加法器有一个缺点：当$N$比较大时，运算速度会慢下来，因为后一级的输入依赖于前一级的输出
   + 先行进位加法器：是另一种类型的进位传播加法器，它解决进位问题的方法是：把加法器分解成若干块，同时增加电路，当每块一有进位时就快速确定此块的输出进位。因此它不需要等待进位行波通过一块内的所有加法器，而是直接先行经过该块。当$N \gt 16$时，先行进位加法器一般比行波进位加法器快很多。然而，加法器的延迟依然随$N$线性增长。
   + 前缀加法器：扩展了先行进位加法器的产成和传播逻辑，可以进行更快的加法运算。前缀加法器的延迟以加法器位数的对数增长，而不是线性增长。它明显提高了速度，特别当加法器位数超过$32$位时，但是，它比简单的先行进位加法器需要消耗更多的硬件资源。

4.  **减法**：改变减除的符号，然后做加法。为了计算$Y=A-B$，首先创建减数$B$的二进制补码，。反转$B$的所有位得到$\overline{B}$，然后加$1$得到$-B=\overline{B}+1$。把这个值与被减数$A$相加得到最后的值。
5. **算数逻辑单元**：将多种算术和逻辑运算组合到一个单元内。例如：典型的算术逻辑单元可以执行加法、减法、量值比较、$AND$和$OR$计算。$ALU$是大多数计算机的核心。
6. **移位器和循环移位器**：用于移动位并完成$2$的次幂的乘法或者除法。
   + **逻辑移位器**——左移或者右移书，以$0$填充空位
   + **算数移位器**——以逻辑移位器一样，但算数右移时会把原来数据的最高有效位填充在新数据的最高有效位上，这对有符号数的乘法除法很有用。算数左移与逻辑左移一样。
   + **循环移位器**——循环移动数字，这样从一端移走的位重新填充到另一端的空位上。

7. ```verilog
   //计数器 system verilog
   mdoule counter#(parameter N=8)
   (input logic clk,
   input logic reset,
    output logic [N-1:0] q);
   always_ff @(posedge clk,posedge reset)
       if(reset) q<=0;
   	else q<=q+1;
   endmodule 
   ```

8. ```verilog
   //移位寄存器（可以看作串行到并行转换器）
   module shiftreg #(parameter N=8)
       (input logic clk,
       input logic reset,load,
       input logic sin,
        input logic [N-1:0] d,
        output logic [N-1:0] q,
        output logic sout);
       always_ff @(posedge clk,posedge reset)
           if(reset) q<=0;
       else if (load) q<=d;
       else 			q<={q[N-2:0],sin};
       assign sout = q[N-1];
   endmodule
   
   ```

9. **扫描链**：通过扫描链技术，移位寄存器经常用于测试时序电路。

10. **存储器**：存储器由一个二维存储器单元阵列构成。存储器可以读取或者写入内容到阵列的一行。这行由*地址* 指定。读出或者写入的值称为*数据* 。一个有$N$位地址和$M$位数据的阵列有$2^N$行和$M$列。每行数据称为一个**字(word)**。因此阵列包含了$2^N$个$M$位字。阵列的*深度* 是行数，*宽度* 是列数，也称为字大小。阵列的大小就是*深度 x 宽度* 。

    1. **位单元**：存储器阵列由位单元的阵列组成，其中每个位单元存储$1$ 位数据，。一个位单元与一个*字线* 和一个 *位线* 相连。对于每一个地址位的组合，存储器将字线设置位高电平，并激活此行中的位单元。当字线为高电平时，就从位线传出或者传入要存储的位。否则，位线就与位单元断开。为了读位单元，位线初始化位浮空。然后，字线打开为高电平，允许存储的值驱动位线为0或者1。为了写位单元，位线强制驱动为期望要输出的值，然后，字线打开为高电平，将位线链接存储位。强制驱动使得位线将改写位单元的内容，将期望的值写入存储位。

    2. **存储端口**：所有存储器都有一个或者多个端口，每一个端口提供对一个存储器地址的读/写访问。多端口存储器可以同时访问多个地址。

    3. **存储器类型** $RAM$的两种类型包括：*动态*$RAM$ 和*静态* $RAM$.动态$RAM$以电容充放电来存储数据，静态$RAM$使用交叉耦合的反向器来存储数据。

    4. $2^N字\times M$位的$RAM$

       ```verilog
       module ram #(parameter N=6,M=32)
           (input logic clk,
           input logic we,
            input logic [N-1:0] adr,
            input logic [M-1:0] din,
            output logic [m-1:0] dout);
           logic [M-1:0] mem[2**N-1:0];
           always_ff @(posedge clk)
               if(we) men[adr]<=din;
           assign dout = mem[adr];
       endmodule
       ```

    5. 4字$\times$3位$ROM$ 

       ```verilog
       module rom(input logic [1:0] adr,
                  output logic [2:0] dout);
           always_comb
               case(adr)
                   2&#39;b00:dout&lt;=3&#39;b011;
                   2&#39;b01:dout&lt;=3&#39;b110;
                   2&#39;b10:dout&lt;=3&#39;b100;
                   2&#39;b11:dout&lt;=3&#39;b010;
               endcase
       endmodule##
       ```

#### 《数字设计和计算机体系结构》数字设计部分完结，体系结构部分跳过

---

---

---

##  The ZYNQ Book  笔记

1. $Zynq$的总的架构包含了两个部分：处理器系统$(PS)$和可编程逻辑$(PL)$。这两个部分可以单独使用，也可以合起来用，而实际上供电电路被设计成独立给每个部分供电，这样$PS$和$PL$部分不被使用的话就可以被断电。

2. 处理器系统

   + 应用处理器单元$(APU)$：$APU$主要由两个$ARM$处理器核组成，每个都关联了一些可计算的单元：一个$NEONTM$媒体处理引擎$(Media\ Prosessing\ Engine,\ MPE)$和浮点单元$(Floating\ Point\ Unit,\ FPU)$ ；一个内存管理单元$(Memory\ Management\ Unit,\ MMU)$；和一个一级$cache$存储器（分为指令和数据两个部分。$APU$里还有一个二级$cache$存储器，再往下还有片上存储器$(On\ Chip\ Memory,OCM)$。最后，由一个一致性控制单元$(Snoop\ Contro\ Unit,SCU)$在$ARM$核和二级$cache$及$OCM$存储器之间形成了桥连接，这个单元还部分负责与$PL$对接。

   + 根据具体型号，其中的$ARM\ Cortex-A9$最高工作频率可达到$1GHz$。两个核中的任意一核分别包含一个一级数据$cache$和一个一级指令$cache$,每个都是$32KB$.一般情况下，这样就能在本地存储常用的数据和指令，实现快速的访问时间和优化的处理器性能。两个核另外还共用一个$512KB$的二级$cache$来存放指令核数据，再往下在$APU$里还有一个$256KB$的片上存储器。$MMU$的主要责任是在虚拟地址和物理地址之间做翻译。
   + 一致性（窥视）控制单元$(SCU)$从事的是一些和两个处理器与一二级$cache$存储器之间的接口相关的任务。$SCU$负责维持两个处理器的数据$cache$存储器和共享的二级$cache$存储器之间的存储一致性。它还初始化并控制对二级$cache$的访问，在必要的时候仲裁从两个核来的访问请求。$SCU$还要通过加速器一致端口$(Accelerator\ Coherency\ Port,ACP)$来管理在$PS$和$PL$之间的访问会话。
   + 作为主$ARM$处理器的附加功能，$NEON$引擎实现了单指令多数据$(Single\ Instruction\ Multiple\ Data,SIMD)$功能来实现媒体和$DSP$类算法的战略加速。$NEON$指令是对标准$ARM$指令集的扩展，可直接使用，也可通过写出遵循特定格式的$C$代码，让编译器产生$NEON$指令。$SIMD$术语意味着$NEON$引擎可以对输入向量中的多组数据同时执行相同的运算来得到对应的输出向量。这种计算范式很好地迎合了像图像和视频处理这样的应用，可以同时对大量的数据样本（像素点）做运算，也适合天生具有并行性的常用的信号处理哈数，比如有限脉冲相应$(FIR)$滤波和快速傅里叶变换$(FFT)$.
   + $NEON$支持多种数据类型，包括有符号和无符号的整数、单精度浮点数和半精度浮点数，但是不支持双精度。如果需要双精度计算，要用到浮点数单元。

####  $Zynq-7000$是特地使用了$ARM Cortex-A9$的 $r3p0$ 版本，基于$V7-A$架构

3. 可编程逻辑

   1. 逻辑部分：$PL$特性

      + 可配置逻辑块$(CLB)$——$CLB$ 是逻辑单元的小规模、普通编组，在$PL$中排列位一个二位阵列，通过可编程互联连接到其他类似的资源，每个$CLB$里包含两个逻辑片，并且紧邻一个开关矩阵

      + 片$Slice$——$CLB$里面的一个子单元，里面有实现组合和时序逻辑电路的资源，$Zynq$的片是由$4$个查找表、$8$个触发器和其他一些逻辑所组成的

      + 查找表$(Lookup\ Table,\ LUT)$——一个灵活的资源，可以实现

        1. 至多$6$个输入的逻辑函数
        2. 一小片只读存储器$(ROM)$
        3. 一小片随机访问存储器$(RAM)$
        4. 一个移位寄存器

        $LUT$可以按需组合起来形成更大的逻辑函数、存储器或移位寄存器

      + 触发器$(Filp-flop,FF)$——一个实现$1$位寄存器的时序电路，带有复位功能。$FF$的一种用处是实现所存
      + 开关矩阵$(Switch\ Matrix)$——每个$CLB$旁都有一个开关矩阵，实现灵活的布线功能来（一）链接$CLB$内的单元；或（二）把一个$CLB$与$PL$内的其他资源连接起来。
      + 进位逻辑$(Carry\ Logic)$——算术电路需要在相邻的片之间传递信号，这就是通过进位逻辑来实现的。进位逻辑把布线和复用器组成链条来链接一个垂直列上的片
      + 输入/输出块$(Input/Output\ Block,\ IOB)$——$IOB$实现了$PL$逻辑资源之间的对接，并且提供物理设备"焊盘"来链接外部电路。每个$IOB$可以处理每一位的输入或输出信号。$IOB$通常位于芯片的周边。

   2. 特殊资源：$DSP48E1$和块$RAM$ 
      + 除了通用的部分，还有两个特殊用途的部件：满足密集存储需要的块$RAM$和用于高速算数的$DSP48E1$片。这两个资源都按列集成在逻辑阵列中，嵌入在逻辑部分中，往往彼此靠近。
      + $Zynq-7000$里的块$RAM$和$Xilinx\ 7$系列$FPGA$里的那些块$RAM$是相同的，它们可以实现$RAM$、$ROM$和先入先出$(FIFO)$缓冲器，同时还支持纠错编码$(ECC)$.

   3. 通用输入/输出：$Zynq$上的通用输入/输出功能$(IOB)$合起来被称作$SelectIO$资源，它们被组织成$50$个$IOB$一组。每个$IOB$有一个焊盘，是于外部世界连接起来做单个信号的输入或输出的。每个$IOB$还包含一个$IOSERDES$资源，可以做并行和串行数据的可编程转换，数据可以是$2$位到$8$位的。
   4. 通信接口：$Zynq$芯片里面含有嵌入在逻辑部分里的$GTX$收发器和高速通信接口块，支持 一些标准的接口，包括$PCI\ Express$、串行$RapidIO$、$SCSI$和$SATA$.
   5. 其他可编程逻辑扩展接口：
      + **模拟-数字转换**——$PL$还具有其他的硬$IP$部件：$XADC$块。这是一个专用的模拟-数字转换器混合信号硬件，具有两个独立的12位ADC，每个可以以$1Msps$对外部模拟输入信号采样。
      + **时钟**——$PL$接收来自$PS$的四个独立的时钟输入，另外还能产生和分发他自己的与$PS$无关的时钟信号。
      + **编程与调试**——在$PL$部分实现了一组$JTAG$端口来实现对$PL$的配置和调试

4. 处理器系统和可编程逻辑的接口

   $Zynq$的表现不仅仅依赖于它的两个组成部分$PS$和$PL$的特性，还在于能把两者协同起来形成完整、集成的系统的能力。这其中起关键作用的，是一组高度定制的$AXI$互联和接口用来在两个部分之间形成桥梁。另外，在$PS$和$PL$之间还有一些其他类型的连接，特别是$EMIO$。

   1. $AXI$标准
      + $AXI4$——用于存储映射连接，它支持最高的性能，通过一簇高达$256$个数据字（或”数据拍（data beats）“）的数据传输来给定一个地址。
      + $AXI-Lite$——一种简化了的链接，只支持每次连接传输一个数据（非批量）。$AXI4-Lite$也是存储映射的，在这种协议下每次传输一个地址和单个数据。
      + $AXI4-Stream$——用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流（非存储器映射）

   2. $AXI$互联和接口
      + **互联**——互联实际上是一个开关，管理并直接传递所连接的$AXI$接口之间的通信。在$PS$内有几个互联，其中有些还直接连接到$PL$，而另一些是只用于内部连接的。这些互联之间的连接也是用$AXI$接口所构成的
      + **接口**——用于在系统内的主机和从机之间传递数据、地址和握手信号的点对点之间连接
      + 所有接口都明确的连接到$PS$内的$AXI$互联，唯一例外的是$ACP$接口，它直接连到$APU$里面的一致性控制单元$(SCU)$。
      + **通用AXI**——一条$32$位数据总线，适合$PL$和$PS$之间的中低速通信。接口是透传的不带缓冲。总共有四个通用接口：两个$PS$做主机，另两个$PL$做主机
      + **加速器一致性端口**——在$PL$和$APU$内的$SCU$之间的单个异步连接，总线宽度位64位，这个端口用来实现$APU\ cache$和$PL$的单元之间的一致性。$PL$是做主机的
      + **高性能端口**——四个高性能$AXI$接口，带有$FIFO$缓冲来提供"批量"读写操作，并支持$PL$和$PS$中的存储器单元 的高速率通信。数据宽度是32或64位，在所有四个接口中$PL$都是做主机的。
   
   3. EMIO接口——从$PS$出来，有几个连接可以经由$PL$到外部接口上，这被称作扩展的$MIO$，即$EMIO$.
   4. 其他PS-PL信号——跨越$PS-PL$边界的其他信号包括看门狗定时器、重启信号、中断和$DMA$接口信号。

5. 安全
   1. 安全引导——$Zynq-7000$芯片的引导方法只限于一种来源——芯片引导必须由处理器驱动。当芯片上电或重启的时候，$PS$的第一个核从外部存储器中引导，然后才会去配置$PL$.通过限制引导的方法为单一来源，就确保了就不可能在$PL$已经配置之后再有人工的方法来装在恶意的软件，同时在处理器已经初始化之后再也没有办法再装载恶意的映像到$PL$中去。
   2. 硬件支持——所有芯片都受益于内置的硬件安全$IP$，这个安全$IP$既可以是$PS$内的硬$IP$包，也可以是$PL$内的软$IP$。下面列出了$Zyqn$芯片和安全有关的一些特性：
      + $ARM\ TrustZone$支持
      + $AES-256$加密
      + 安全认证和启动
      + $HMAC$位流认证
      + $FSBL\ RAS-2048$认证
      + 禁止强硬回读
      + $JTAG$禁止/监视
      + $SEU$检查器

6. 在选择芯片时所涉及的因素

   | 分类         | 因素                                                         |
   | ------------ | ------------------------------------------------------------ |
   | 芯片能力     | 处理器性能<br />逻辑性能<br />存储器性能<br />支持高速算数<br />支持$I/O$和通信<br />安全特性和逻辑部分之间的带宽<br />处理器和逻辑部分之间的延迟 |
   | 商业因素     | 物料表<br />开发成本<br />集成(和隐形成本)<br />芯片供应的长期性和技术支持<br />质量和可靠性<br />实现现场升级的容易程度(和成本) |
   | 设计和开发   | 进入市场的时间<br />快速、便捷和可靠的设计流<br />集成的验证<br />与其他开发工具的集成<br />支持团队设计流<br />支持设计重用<br />支持工业标准的设计格式<br />支持所需的设计入口方法<br />文档和技术支持 |
   | 芯片物理特性 | 物理尺寸<br />功耗<br />易于集成和生产的PCB的复杂程度<br />可连接性<br />耐久性<br />是否对辐射敏感<br />支持的温度范围 |
   | 灵活性       | 可伸缩性（有更大或更小的芯片，而且只需要很小的甚至不需要工作就可以调整<br />可移植性(用标准格式设计可以移植到其他平台或从其他平台移植过来)<br />再编程能力(可以现场甚至在运行时刻动态改变功能)<br />易于划分(能在硬件和软件之间划分功能)<br />可扩展性(易于集成新的功能) |

   



