# 数字电路设计及FPGA

### 一门最好的语言就是在你的环境里已经使用的语言或者是客户要求使用的语言 

1. 同步时序电路：包含环路的环，它的输出直接反馈到输入，它们是时许电路而不是组合电路。组合逻辑没有环路和竞争。为了避免这些问题，设计师在路径中插入寄存器来断开环路。将电路转变成组合逻辑和寄存器的集合。寄存器包含系统的状态，这些状态仅仅在时钟到达时发生改变，所有说状态**同步于**时钟信号。如果时钟足够慢，使得在下一个时钟沿到达之前输入到寄存器的信号都可以稳定下来，那么所有的竞争都将被消除。

2. **同步时序电路**有一个时钟输入，它的上升沿表示时序电路状态转变发生的事件。我们经常使用术语*当前状态*和*下一个状态*来区分目前系统的状态和下一个时钟沿系统将要进入的状态。

3. 时序规范包括上界时间$t_{pcq}$和下界时间$t_{ccq}$ ，它是从时钟的上升沿知道**输出**改变的时间以及**建立**时间$t_{setup}$和**保持**时间$t_{hold}$,它表示当前**输入**必须相对于时钟的上升沿稳定。

4. **同步时序电路的组成**规则告诉我们，一个电路是同步时序电路，如果它由相互连接的电路元件构成，且需要满足一下条件。
   + 每一个电路元件是寄存器或者是组合电路
   + 至少有一个元件是寄存器
   + 所有寄存器都接收同一个时钟信号
   + 每个环路至少包含一个寄存器

5. 两种常见的同步时序电路成为**有限状态机**和**流水线**

6. 由电路图导出状态机
   + 检查电路，标明输入、输出和状态位
   + 写出下一个状态和输出表
   + 创建下一个状态和输出表
   + 删除不可达状态来简化下一个状态表
   + 给每个有效状态位组合指定状态名称
   + 用状态名称重写下一个状态和输出表
   + 画出状态转换图
   + 使用文字阐述有限状态机的功能

7. 有限状态机小结

   + 确定输入和输出
   + 画出状态转换图
   + 对于$Moore$型状态机：
     + 写出状态转换表
     + 写出输出表

   + 对于$Mealy$型状态机：
     + 写出组合的状态转换表和输出表

   + 选择状态编码——这个选择将影响硬件设计
   + 为下一个状态和输出逻辑写出布尔表达式
   + 画出电路草图

8. **动态约束**

   为了电路对输入正确采样，在时钟上升沿到来前，输入必须在*建立时间*(setup time) $t_{setup}$内保持稳定，在时钟上升沿后，输入必须保持至少*保持时间*（hold time）$t_{hold}$内保持稳定。建立时间和保持时间统称为电路的*孔径时间*，因为它是输入保持稳定状态的时间总和。

   **动态约束**是指同步时序电路的输入必须在时钟沿附近的建立和维持孔径时间内保持稳定

9. **建立时间约束** 

   $t_{pd}\leq T_c-(t_{pcp}+t_{setup})$ 制造商确定触发器时钟到$Q$的传播延迟$t_{pcq}$和建立时间$t_{setup}$.在圆括号内的项$t_{pd}+t_{setup}$称为*时序开销*。理想状态下，整个周期时间$T_c$都应用于组合逻辑中有用的计算，其传播延迟为$t_{pd}$。但是，触发器的时序开销占用了周期时间。上式称为*建立时间约束*或*最大延迟约束*，因为它取决于建立时间，并限制通过组合逻辑的最大延迟。
   
   + 解决问题的方法有两个：增加时钟周期或重新设计组合逻辑来缩短传播延迟

10. **保持时间约束**

    $t_{cd}\geq t_{hold}-t_{ccq}$ 称为*保持时间约束*或者*最小延迟约束*，因为它限制了通过组合逻辑的最小延迟。如果不能满足，则唯一的解决方法是重新设计电路以便增加组合逻辑的最小延迟。与建立约束不同，他们不能通过调整时钟周期来改正。

11. 数字系统设计人员的目标是：对于给定的异步输入，确保遇到的亚稳态电压的概率足够小。为了确保产生正确的逻辑电平，所有的异步输入必须经过*同步器* 。

    + 用2个触发器来建立同步器的简单方法。$F1$在$CLK$的上升沿对$D$进行采样，如果$D$在这个时刻发生改变，则输出$D2$将出现暂时的亚稳态。如果时钟周期足够长，则在周期结束前$D2$成为一个有效逻辑电平的概率很高。然后$F2$对$D2$进行采样，它现在是稳定的，将产生一个好的输出$Q$ ($F1$$F2$为$D$触发器)

    + 如果同步器的输出$Q$为亚稳态，那么这个同步器将*失效*。

    + 系统的可靠性通常由**平均失效间隔时间（MTBF）**度量。根据定义可以看出,**MTBF**是系统失效之间的平均时间。它是系统失效概率的倒数：

      **MTBF**=$\frac1{P(失效)/sec}$=$\frac{T_ce^{T_c-t_{setup}}}{NT_0}$ 

12. 系统的速度可以用延迟和通过系统的信息吞吐量来度量。**任务**定义为经过处理后能产生一组输出的一组输入。**延迟**是从开始到结束所需的时间。**吞吐量**是系统单位时间内产生的任务的数量

13. 与输出只取决于当前输入的组合逻辑电路相比，时许逻辑电路的输出取决于当前和先前的输入。换句话说，时许逻辑电路记忆先前的输入信息。这种记忆称为逻辑的状态
    + 时许逻辑电路很难分析，并用以产生设计错误，所以我们只关心小部分成熟的模块。需要掌握的最重要元器件就是触发器，它接收时钟和输入$D$，产生一个输出$Q$。触发器在时钟的上升沿将$D$复制到$Q$，其他时候保持$Q$原来的状态。共享一个公共时钟的触发器称为寄存器。触发器还可以接收复位和使能控制信号。
    + 虽然有多种形式的时许逻辑，但我们只考虑最容易设计的同步时许逻辑电路。同步时许逻辑电路包含由时钟驱动寄存器隔开的组合逻辑块。电路的状态存储在寄存器中，仅在时钟沿到达时进行更新。
    + 同步时许逻辑电路的时序规范包括时钟到$Q$的传播延迟$t_{pcq}$和最小延迟$t_{ccq}$，建立时间$t_{setup}$和保持时间$t_{hold}$。为了正确操作，它们的输入在孔径时间内必须稳定。孔径时间在时钟的上升沿之前启动建立时间，在时钟的上升沿之后结束保持时间。系统的最小延迟周期$T_c$等于通过组合逻辑块的传播延迟$t_{pd}$加上寄存器的$t_{pcq}+t_{setup}$。为了正确操作，通过寄存器和组合逻辑的最小延迟必须大于$t_{hold}$。与常见的误解相反，**保持时间不影响周期时间**

14. 锁存器：当时钟为$HIGH$时，$D$锁存器是透明的，允许数据从输入流向输出。当时钟为$LOW$时锁存器变为不透明的，保持原来的状态。不是所有的综合工具都能很好地支持锁存器。除非你知道工具支持锁存器，或者你有理由使用它们，否则，最好不使用他们而使用边沿触发器。$always\_latch$等同于$always @ (clk,d)$ ,它是$system\ verilog$中用来描述锁存器的首选风格. 

    $always\_comb$等同于$always\ @(a)$，但比$always@(a)$更好，因为它避免了在$always$语句中由于信号改名或添加信号所带来的错误。  

### 数字模块

1. **半加器**：半加器有两个输入$A$和$B$，两个输出$S$和$C_{out}$.$S$是$A$和$B$的和，$C_{out}$是进位
2. **全加器**：多了接收进位$C_{in}$ 
3. **进位传播加法器**：一个$N$位加法器将两个$N$位输入$(A、B)$和一位进位$C_{in}$相加，产生一个$N$位结果$S$和一个输出进位$C_{out}$。
   + 行波进位加法器：构造$N$位进位传播加法器的最简单方法就是把$N$个全加器串联起来。其中一级的$C_{out}$就是下一级的$C_{in}$。这是规模化和规整化的一个应用范例：全加器模块在一个更大的系统中被多次重用。行波进位加法器有一个缺点：当$N$比较大时，运算速度会慢下来，因为后一级的输入依赖于前一级的输出
   + 先行进位加法器：是另一种类型的进位传播加法器，它解决进位问题的方法是：把加法器分解成若干块，同时增加电路，当每块一有进位时就快速确定此块的输出进位。因此它不需要等待进位行波通过一块内的所有加法器，而是直接先行经过该块。当$N \gt 16$时，先行进位加法器一般比行波进位加法器快很多。然而，加法器的延迟依然随$N$线性增长。
   + 前缀加法器：扩展了先行进位加法器的产成和传播逻辑，可以进行更快的加法运算。前缀加法器的延迟以加法器位数的对数增长，而不是线性增长。它明显提高了速度，特别当加法器位数超过$32$位时，但是，它比简单的先行进位加法器需要消耗更多的硬件资源。

4.  **减法**：改变减除的符号，然后做加法。为了计算$Y=A-B$，首先创建减数$B$的二进制补码，。反转$B$的所有位得到$\overline{B}$，然后加$1$得到$-B=\overline{B}+1$。把这个值与被减数$A$相加得到最后的值。
5. **算数逻辑单元**：将多种算术和逻辑运算组合到一个单元内。例如：典型的算术逻辑单元可以执行加法、减法、量值比较、$AND$和$OR$计算。$ALU$是大多数计算机的核心。
6. **移位器和循环移位器**：用于移动位并完成$2$的次幂的乘法或者除法。
   + **逻辑移位器**——左移或者右移书，以$0$填充空位
   + **算数移位器**——以逻辑移位器一样，但算数右移时会把原来数据的最高有效位填充在新数据的最高有效位上，这对有符号数的乘法除法很有用。算数左移与逻辑左移一样。
   + **循环移位器**——循环移动数字，这样从一端移走的位重新填充到另一端的空位上。

7. ```verilog
   //计数器 system verilog
   mdoule counter#(parameter N=8)
   (input logic clk,
   input logic reset,
    output logic [N-1:0] q);
   always_ff @(posedge clk,posedge reset)
       if(reset) q<=0;
   	else q<=q+1;
   endmodule 
   ```

8. ```verilog
   //移位寄存器（可以看作串行到并行转换器）
   module shiftreg #(parameter N=8)
       (input logic clk,
       input logic reset,load,
       input logic sin,
        input logic [N-1:0] d,
        output logic [N-1:0] q,
        output logic sout);
       always_ff @(posedge clk,posedge reset)
           if(reset) q<=0;
       else if (load) q<=d;
       else 			q<={q[N-2:0],sin};
       assign sout = q[N-1];
   endmodule
   
   ```

9. **扫描链**：通过扫描链技术，移位寄存器经常用于测试时序电路。

10. **存储器**：存储器由一个二维存储器单元阵列构成。存储器可以读取或者写入内容到阵列的一行。这行由*地址* 指定。读出或者写入的值称为*数据* 。一个有$N$位地址和$M$位数据的阵列有$2^N$行和$M$列。每行数据称为一个**字(word)**。因此阵列包含了$2^N$个$M$位字。阵列的*深度* 是行数，*宽度* 是列数，也称为字大小。阵列的大小就是*深度 x 宽度* 。

    1. **位单元**：存储器阵列由位单元的阵列组成，其中每个位单元存储$1$ 位数据，。一个位单元与一个*字线* 和一个 *位线* 相连。对于每一个地址位的组合，存储器将字线设置位高电平，并激活此行中的位单元。当字线为高电平时，就从位线传出或者传入要存储的位。否则，位线就与位单元断开。为了读位单元，位线初始化位浮空。然后，字线打开为高电平，允许存储的值驱动位线为0或者1。为了写位单元，位线强制驱动为期望要输出的值，然后，字线打开为高电平，将位线链接存储位。强制驱动使得位线将改写位单元的内容，将期望的值写入存储位。

    2. **存储端口**：所有存储器都有一个或者多个端口，每一个端口提供对一个存储器地址的读/写访问。多端口存储器可以同时访问多个地址。

    3. **存储器类型** $RAM$的两种类型包括：*动态*$RAM$ 和*静态* $RAM$.动态$RAM$以电容充放电来存储数据，静态$RAM$使用交叉耦合的反向器来存储数据。

    4. $2^N字\times M$位的$RAM$

       ```verilog
       module ram #(parameter N=6,M=32)
           (input logic clk,
           input logic we,
            input logic [N-1:0] adr,
            input logic [M-1:0] din,
            output logic [m-1:0] dout);
           logic [M-1:0] mem[2**N-1:0];
           always_ff @(posedge clk)
               if(we) men[adr]<=din;
           assign dout = mem[adr];
       endmodule
       ```

    5. 4字$\times$3位$ROM$ 

       ```verilog
       module rom(input logic [1:0] adr,
                  output logic [2:0] dout);
           always_comb
               case(adr)
                   2'b00:dout<=3'b011;
                   2'b01:dout<=3'b110;
                   2'b10:dout<=3'b100;
                   2'b11:dout<=3'b010;
               endcase
       endmodule
       ```

### 体系结构

1. 计算机语言的单词叫做**指令**，计算机的词汇表叫做**指令集** 。
2. $MIPS$体系结构的4个设计准则：
   1. 简单设计有助于规整化
   2. 加快常见的功能
   3. 越小的设计越快
   4. 好的设计需要好的折中方法

3. 字节寻址存储器的组织方式由**大端**和**小端**两种形式。在两种格式中，最高有效字节（MSB）在左边，最低有效字节（LSB）在右边。在大端形式的机器中，第0字节在最高有效字节，在小端形式的机器中，第0个字节在最低有效字节。两种格式的字地址相同，并指向相同的4字节。唯一不同的时一个字中字节的地址不同。51使用大端，x86 arm DSP 使用小端

4. $MIPS$与$X86$的主要差异

   | 特征     | MIPS           | x86                     |
   | -------- | -------------- | ----------------------- |
   | 寄存器数 | 32个通用寄存器 | 8个(在用途上有一些限制) |
   | 操作数的个数 | 3个(2个源，1个目的) | 2个(1个源，1个源/目的) |
   | 操作数位置 | 寄存器或立即数 | 寄存器、立即数或存储器 |
   | 操作数大小 | 32位 | 8、16或32 |
   | 条件码 | 无 | 有 |
   | 指令类型 | 简单 | 简单类型和复杂类型 |
   | 指令编码 | 固定的，4字节长 | 可变长，1~15字节 |

   

   

