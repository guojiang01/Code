# 数字电路设计及FPGA

### 一门最好的语言就是在你的环境里已经使用的语言或者是客户要求使用的语言 

1. 同步时序电路：包含环路的环，它的输出直接反馈到输入，它们是时许电路而不是组合电路。组合逻辑没有环路和竞争。为了避免这些问题，设计师在路径中插入寄存器来断开环路。将电路转变成组合逻辑和寄存器的集合。寄存器包含系统的状态，这些状态仅仅在时钟到达时发生改变，所有说状态**同步于**时钟信号。如果时钟足够慢，使得在下一个时钟沿到达之前输入到寄存器的信号都可以稳定下来，那么所有的竞争都将被消除。

2. **同步时序电路**有一个时钟输入，它的上升沿表示时序电路状态转变发生的事件。我们经常使用术语*当前状态*和*下一个状态*来区分目前系统的状态和下一个时钟沿系统将要进入的状态。

3. 时序规范包括上界时间$t_{pcq}$和下界时间$t_{ccq}$ ，它是从时钟的上升沿知道**输出**改变的时间以及**建立**时间$t_{setup}$和**保持**时间$t_{hold}$,它表示当前**输入**必须相对于时钟的上升沿稳定。

4. **同步时序电路的组成**规则告诉我们，一个电路是同步时序电路，如果它由相互连接的电路元件构成，且需要满足一下条件。
   + 每一个电路元件是寄存器或者是组合电路
   + 至少有一个元件是寄存器
   + 所有寄存器都接收同一个时钟信号
   + 每个环路至少包含一个寄存器

5. 两种常见的同步时序电路成为**有限状态机**和**流水线**

6. 由电路图导出状态机
   + 检查电路，标明输入、输出和状态位
   + 写出下一个状态和输出表
   + 创建下一个状态和输出表
   + 删除不可达状态来简化下一个状态表
   + 给每个有效状态位组合指定状态名称
   + 用状态名称重写下一个状态和输出表
   + 画出状态转换图
   + 使用文字阐述有限状态机的功能

7. 有限状态机小结

   + 确定输入和输出
   + 画出状态转换图
   + 对于$Moore$型状态机：
     + 写出状态转换表
     + 写出输出表

   + 对于$Mealy$型状态机：
     + 写出组合的状态转换表和输出表

   + 选择状态编码——这个选择将影响硬件设计
   + 为下一个状态和输出逻辑写出布尔表达式
   + 画出电路草图

8. **动态约束**

   为了电路对输入正确采样，在时钟上升沿到来前，输入必须在*建立时间*(setup time) $t_{setup}$内保持稳定，在时钟上升沿后，输入必须保持至少*保持时间*（hold time）$t_{hold}$内保持稳定。建立时间和保持时间统称为电路的*孔径时间*，因为它是输入保持稳定状态的时间总和。

   **动态约束**是指同步时序电路的输入必须在时钟沿附近的建立和维持孔径时间内保持稳定

9. **建立时间约束** 

   $t_{pd}\leq T_c-(t_{pcp}+t_{setup})$ 制造商确定触发器时钟到$Q$的传播延迟$t_{pcq}$和建立时间$t_{setup}$.在圆括号内的项$t_{pd}+t_{setup}$称为*时序开销*。理想状态下，整个周期时间$T_c$都应用于组合逻辑中有用的计算，其传播延迟为$t_{pd}$。但是，触发器的时序开销占用了周期时间。上式称为*建立时间约束*或*最大延迟约束*，因为它取决于建立时间，并限制通过组合逻辑的最大延迟。
   
   + 解决问题的方法有两个：增加时钟周期或重新设计组合逻辑来缩短传播延迟

10. **保持时间约束**

    $t_{cd}\geq t_{hold}-t_{ccq}$ 称为*保持时间约束*或者*最小延迟约束*，因为它限制了通过组合逻辑的最小延迟。如果不能满足，则唯一的解决方法是重新设计电路以便增加组合逻辑的最小延迟。与建立约束不同，他们不能通过调整时钟周期来改正。

11. 数字系统设计人员的目标是：对于给定的异步输入，确保遇到的亚稳态电压的概率足够小。为了确保产生正确的逻辑电平，所有的异步输入必须经过*同步器* 。

    + 用2个触发器来建立同步器的简单方法。$F1$在$CLK$的上升沿对$D$进行采样，如果$D$在这个时刻发生改变，则输出$D2$将出现暂时的亚稳态。如果时钟周期足够长，则在周期结束前$D2$成为一个有效逻辑电平的概率很高。然后$F2$对$D2$进行采样，它现在是稳定的，将产生一个好的输出$Q$ ($F1$$F2$为$D$触发器)

    + 如果同步器的输出$Q$为亚稳态，那么这个同步器将*失效*。

    + 系统的可靠性通常由**平均失效间隔时间（MTBF）**度量。根据定义可以看出,**MTBF**是系统失效之间的平均时间。它是系统失效概率的倒数：

      **MTBF**=$\frac1{P(失效)/sec}$=$\frac{T_ce^{T_c-t_{setup}}}{NT_0}$ 

12. 系统的速度可以用延迟和通过系统的信息吞吐量来度量。**任务**定义为经过处理后能产生一组输出的一组输入。**延迟**是从开始到结束所需的时间。**吞吐量**是系统单位时间内产生的任务的数量

13. 与输出只取决于当前输入的组合逻辑电路相比，时许逻辑电路的输出取决于当前和先前的输入。换句话说，时许逻辑电路记忆先前的输入信息。这种记忆称为逻辑的状态
    + 时许逻辑电路很难分析，并用以产生设计错误，所以我们只关心小部分成熟的模块。需要掌握的最重要元器件就是触发器，它接收时钟和输入$D$，产生一个输出$Q$。触发器在时钟的上升沿将$D$复制到$Q$，其他时候保持$Q$原来的状态。共享一个公共时钟的触发器称为寄存器。触发器还可以接收复位和使能控制信号。
    + 虽然有多种形式的时许逻辑，但我们只考虑最容易设计的同步时许逻辑电路。同步时许逻辑电路包含由时钟驱动寄存器隔开的组合逻辑块。电路的状态存储在寄存器中，仅在时钟沿到达时进行更新。
    + 同步时许逻辑电路的时序规范包括时钟到$Q$的传播延迟$t_{pcq}$和最小延迟$t_{ccq}$，建立时间$t_{setup}$和保持时间$t_{hold}$。为了正确操作，它们的输入在孔径时间内必须稳定。孔径时间在时钟的上升沿之前启动建立时间，在时钟的上升沿之后结束保持时间。系统的最小延迟周期$T_c$等于通过组合逻辑块的传播延迟$t_{pd}$加上寄存器的$t_{pcq}+t_{setup}$。为了正确操作，通过寄存器和组合逻辑的最小延迟必须大于$t_{hold}$。与常见的误解相反，**保持时间不影响周期时间**

14. 锁存器：当时钟为$HIGH$时，$D$锁存器是透明的，允许数据从输入流向输出。当时钟为$LOW$时锁存器变为不透明的，保持原来的状态。不是所有的综合工具都能很好地支持锁存器。除非你知道工具支持锁存器，或者你有理由使用它们，否则，最好不使用他们而使用边沿触发器。$always\_latch$等同于$always @ (clk,d)$ ,它是$system\ verilog$中用来描述锁存器的首选风格. 

    $always\_comb$等同于$always\ @(a)$，但比$always@(a)$更好，因为它避免了在$always$语句中由于信号改名或添加信号所带来的错误。  

### 数字模块

1. **半加器**：半加器有两个输入$A$和$B$，两个输出$S$和$C_{out}$.$S$是$A$和$B$的和，$C_{out}$是进位
2. **全加器**：多了接收进位$C_{in}$ 
3. **进位传播加法器**：一个$N$位加法器将两个$N$位输入$(A、B)$和一位进位$C_{in}$相加，产生一个$N$位结果$S$和一个输出进位$C_{out}$。
   + 行波进位加法器：构造$N$位进位传播加法器的最简单方法就是把$N$个全加器串联起来。其中一级的$C_{out}$就是下一级的$C_{in}$。这是规模化和规整化的一个应用范例：全加器模块在一个更大的系统中被多次重用。行波进位加法器有一个缺点：当$N$比较大时，运算速度会慢下来，因为后一级的输入依赖于前一级的输出
   + 先行进位加法器：是另一种类型的进位传播加法器，它解决进位问题的方法是：把加法器分解成若干块，同时增加电路，当每块一有进位时就快速确定此块的输出进位。因此它不需要等待进位行波通过一块内的所有加法器，而是直接先行经过该块。当$N \gt 16$时，先行进位加法器一般比行波进位加法器快很多。然而，加法器的延迟依然随$N$线性增长。
   + 前缀加法器：扩展了先行进位加法器的产成和传播逻辑，可以进行更快的加法运算。前缀加法器的延迟以加法器位数的对数增长，而不是线性增长。它明显提高了速度，特别当加法器位数超过$32$位时，但是，它比简单的先行进位加法器需要消耗更多的硬件资源。

4.  **减法**：改变减除的符号，然后做加法。为了计算$Y=A-B$，首先创建减数$B$的二进制补码，。反转$B$的所有位得到$\overline{B}$，然后加$1$得到$-B=\overline{B}+1$。把这个值与被减数$A$相加得到最后的值。
5. **算数逻辑单元**：将多种算术和逻辑运算组合到一个单元内。例如：典型的算术逻辑单元可以执行加法、减法、量值比较、$AND$和$OR$计算。$ALU$是大多数计算机的核心。
6. **移位器和循环移位器**：用于移动位并完成$2$的次幂的乘法或者除法。
   + **逻辑移位器**——左移或者右移书，以$0$填充空位
   + **算数移位器**——以逻辑移位器一样，但算数右移时会把原来数据的最高有效位填充在新数据的最高有效位上，这对有符号数的乘法除法很有用。算数左移与逻辑左移一样。
   + **循环移位器**——循环移动数字，这样从一端移走的位重新填充到另一端的空位上。

7. ```verilog
   //计数器 system verilog
   mdoule counter#(parameter N=8)
   (input logic clk,
   input logic reset,
    output logic [N-1:0] q);
   always_ff @(posedge clk,posedge reset)
       if(reset) q<=0;
   	else q<=q+1;
   endmodule 
   ```

8. ```verilog
   //移位寄存器（可以看作串行到并行转换器）
   module shiftreg #(parameter N=8)
       (input logic clk,
       input logic reset,load,
       input logic sin,
        input logic [N-1:0] d,
        output logic [N-1:0] q,
        output logic sout);
       always_ff @(posedge clk,posedge reset)
           if(reset) q<=0;
       else if (load) q<=d;
       else 			q<={q[N-2:0],sin};
       assign sout = q[N-1];
   endmodule
   
   ```

9. **扫描链**：通过扫描链技术，移位寄存器经常用于测试时序电路。

10. **存储器**：存储器由一个二维存储器单元阵列构成。存储器可以读取或者写入内容到阵列的一行。这行由*地址* 指定。读出或者写入的值称为*数据* 。一个有$N$位地址和$M$位数据的阵列有$2^N$行和$M$列。每行数据称为一个**字(word)**。因此阵列包含了$2^N$个$M$位字。阵列的*深度* 是行数，*宽度* 是列数，也称为字大小。阵列的大小就是*深度 x 宽度* 。

    1. **位单元**：存储器阵列由位单元的阵列组成，其中每个位单元存储$1$ 位数据，。一个位单元与一个*字线* 和一个 *位线* 相连。对于每一个地址位的组合，存储器将字线设置位高电平，并激活此行中的位单元。当字线为高电平时，就从位线传出或者传入要存储的位。否则，位线就与位单元断开。为了读位单元，位线初始化位浮空。然后，字线打开为高电平，允许存储的值驱动位线为0或者1。为了写位单元，位线强制驱动为期望要输出的值，然后，字线打开为高电平，将位线链接存储位。强制驱动使得位线将改写位单元的内容，将期望的值写入存储位。

    2. **存储端口**：所有存储器都有一个或者多个端口，每一个端口提供对一个存储器地址的读/写访问。多端口存储器可以同时访问多个地址。

    3. **存储器类型** $RAM$的两种类型包括：*动态*$RAM$ 和*静态* $RAM$.动态$RAM$以电容充放电来存储数据，静态$RAM$使用交叉耦合的反向器来存储数据。

    4. $2^N字\times M$位的$RAM$

       ```verilog
       module ram #(parameter N=6,M=32)
           (input logic clk,
           input logic we,
            input logic [N-1:0] adr,
            input logic [M-1:0] din,
            output logic [m-1:0] dout);
           logic [M-1:0] mem[2**N-1:0];
           always_ff @(posedge clk)
               if(we) men[adr]<=din;
           assign dout = mem[adr];
       endmodule
       ```

    5. 4字$\times$3位$ROM$ 

       ```verilog
       module rom(input logic [1:0] adr,
                  output logic [2:0] dout);
           always_comb
               case(adr)
                   2&#39;b00:dout&lt;=3&#39;b011;
                   2&#39;b01:dout&lt;=3&#39;b110;
                   2&#39;b10:dout&lt;=3&#39;b100;
                   2&#39;b11:dout&lt;=3&#39;b010;
               endcase
       endmodule##
       ```

#### 《数字设计和计算机体系结构》数字设计部分完结，体系结构部分跳过

---

---

---

##  The ZYNQ Book  笔记

1. $Zynq$的总的架构包含了两个部分：处理器系统$(PS)$和可编程逻辑$(PL)$。这两个部分可以单独使用，也可以合起来用，而实际上供电电路被设计成独立给每个部分供电，这样$PS$和$PL$部分不被使用的话就可以被断电。

2. 处理器系统

   + 应用处理器单元$(APU)$：$APU$主要由两个$ARM$处理器核组成，每个都关联了一些可计算的单元：一个$NEONTM$媒体处理引擎$(Media\ Prosessing\ Engine,\ MPE)$和浮点单元$(Floating\ Point\ Unit,\ FPU)$ ；一个内存管理单元$(Memory\ Management\ Unit,\ MMU)$；和一个一级$cache$存储器（分为指令和数据两个部分。$APU$里还有一个二级$cache$存储器，再往下还有片上存储器$(On\ Chip\ Memory,OCM)$。最后，由一个一致性控制单元$(Snoop\ Contro\ Unit,SCU)$在$ARM$核和二级$cache$及$OCM$存储器之间形成了桥连接，这个单元还部分负责与$PL$对接。

   + 根据具体型号，其中的$ARM\ Cortex-A9$最高工作频率可达到$1GHz$。两个核中的任意一核分别包含一个一级数据$cache$和一个一级指令$cache$,每个都是$32KB$.一般情况下，这样就能在本地存储常用的数据和指令，实现快速的访问时间和优化的处理器性能。两个核另外还共用一个$512KB$的二级$cache$来存放指令核数据，再往下在$APU$里还有一个$256KB$的片上存储器。$MMU$的主要责任是在虚拟地址和物理地址之间做翻译。
   + 一致性（窥视）控制单元$(SCU)$从事的是一些和两个处理器与一二级$cache$存储器之间的接口相关的任务。$SCU$负责维持两个处理器的数据$cache$存储器和共享的二级$cache$存储器之间的存储一致性。它还初始化并控制对二级$cache$的访问，在必要的时候仲裁从两个核来的访问请求。$SCU$还要通过加速器一致端口$(Accelerator\ Coherency\ Port,ACP)$来管理在$PS$和$PL$之间的访问会话。
   + 作为主$ARM$处理器的附加功能，$NEON$引擎实现了单指令多数据$(Single\ Instruction\ Multiple\ Data,SIMD)$功能来实现媒体和$DSP$类算法的战略加速。$NEON$指令是对标准$ARM$指令集的扩展，可直接使用，也可通过写出遵循特定格式的$C$代码，让编译器产生$NEON$指令。$SIMD$术语意味着$NEON$引擎可以对输入向量中的多组数据同时执行相同的运算来得到对应的输出向量。这种计算范式很好地迎合了像图像和视频处理这样的应用，可以同时对大量的数据样本（像素点）做运算，也适合天生具有并行性的常用的信号处理哈数，比如有限脉冲相应$(FIR)$滤波和快速傅里叶变换$(FFT)$.
   + $NEON$支持多种数据类型，包括有符号和无符号的整数、单精度浮点数和半精度浮点数，但是不支持双精度。如果需要双精度计算，要用到浮点数单元。

####  $Zynq-7000$是特地使用了$ARM Cortex-A9$的 $r3p0$ 版本，基于$V7-A$架构

3. 可编程逻辑

   1. 逻辑部分：$PL$特性

      + 可配置逻辑块$(CLB)$——$CLB$ 是逻辑单元的小规模、普通编组，在$PL$中排列位一个二位阵列，通过可编程互联连接到其他类似的资源，每个$CLB$里包含两个逻辑片，并且紧邻一个开关矩阵

      + 片$Slice$——$CLB$里面的一个子单元，里面有实现组合和时序逻辑电路的资源，$Zynq$的片是由$4$个查找表、$8$个触发器和其他一些逻辑所组成的

      + 查找表$(Lookup\ Table,\ LUT)$——一个灵活的资源，可以实现

        1. 至多$6$个输入的逻辑函数
        2. 一小片只读存储器$(ROM)$
        3. 一小片随机访问存储器$(RAM)$
        4. 一个移位寄存器

        $LUT$可以按需组合起来形成更大的逻辑函数、存储器或移位寄存器

      + 触发器$(Filp-flop,FF)$——一个实现$1$位寄存器的时序电路，带有复位功能。$FF$的一种用处是实现所存
      + 开关矩阵$(Switch\ Matrix)$——每个$CLB$旁都有一个开关矩阵，实现灵活的布线功能来（一）链接$CLB$内的单元；或（二）把一个$CLB$与$PL$内的其他资源连接起来。
      + 进位逻辑$(Carry\ Logic)$——算术电路需要在相邻的片之间传递信号，这就是通过进位逻辑来实现的。进位逻辑把布线和复用器组成链条来链接一个垂直列上的片
      + 输入/输出块$(Input/Output\ Block,\ IOB)$——$IOB$实现了$PL$逻辑资源之间的对接，并且提供物理设备"焊盘"来链接外部电路。每个$IOB$可以处理每一位的输入或输出信号。$IOB$通常位于芯片的周边。

   2. 特殊资源：$DSP48E1$和块$RAM$ 
      + 除了通用的部分，还有两个特殊用途的部件：满足密集存储需要的块$RAM$和用于高速算数的$DSP48E1$片。这两个资源都按列集成在逻辑阵列中，嵌入在逻辑部分中，往往彼此靠近。
      + $Zynq-7000$里的块$RAM$和$Xilinx\ 7$系列$FPGA$里的那些块$RAM$是相同的，它们可以实现$RAM$、$ROM$和先入先出$(FIFO)$缓冲器，同时还支持纠错编码$(ECC)$.

   3. 通用输入/输出：$Zynq$上的通用输入/输出功能$(IOB)$合起来被称作$SelectIO$资源，它们被组织成$50$个$IOB$一组。每个$IOB$有一个焊盘，是于外部世界连接起来做单个信号的输入或输出的。每个$IOB$还包含一个$IOSERDES$资源，可以做并行和串行数据的可编程转换，数据可以是$2$位到$8$位的。
   4. 通信接口：$Zynq$芯片里面含有嵌入在逻辑部分里的$GTX$收发器和高速通信接口块，支持 一些标准的接口，包括$PCI\ Express$、串行$RapidIO$、$SCSI$和$SATA$.
   5. 其他可编程逻辑扩展接口：
      + **模拟-数字转换**——$PL$还具有其他的硬$IP$部件：$XADC$块。这是一个专用的模拟-数字转换器混合信号硬件，具有两个独立的12位ADC，每个可以以$1Msps$对外部模拟输入信号采样。
      + **时钟**——$PL$接收来自$PS$的四个独立的时钟输入，另外还能产生和分发他自己的与$PS$无关的时钟信号。
      + **编程与调试**——在$PL$部分实现了一组$JTAG$端口来实现对$PL$的配置和调试

4. 处理器系统和可编程逻辑的接口

   $Zynq$的表现不仅仅依赖于它的两个组成部分$PS$和$PL$的特性，还在于能把两者协同起来形成完整、集成的系统的能力。这其中起关键作用的，是一组高度定制的$AXI$互联和接口用来在两个部分之间形成桥梁。另外，在$PS$和$PL$之间还有一些其他类型的连接，特别是$EMIO$。

   1. $AXI$标准
      + $AXI4$——用于存储映射连接，它支持最高的性能，通过一簇高达$256$个数据字（或”数据拍（data beats）“）的数据传输来给定一个地址。
      + $AXI-Lite$——一种简化了的链接，只支持每次连接传输一个数据（非批量）。$AXI4-Lite$也是存储映射的，在这种协议下每次传输一个地址和单个数据。
      + $AXI4-Stream$——用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流（非存储器映射）

   2. $AXI$互联和接口
      + **互联**——互联实际上是一个开关，管理并直接传递所连接的$AXI$接口之间的通信。在$PS$内有几个互联，其中有些还直接连接到$PL$，而另一些是只用于内部连接的。这些互联之间的连接也是用$AXI$接口所构成的
      + **接口**——用于在系统内的主机和从机之间传递数据、地址和握手信号的点对点之间连接
      + 所有接口都明确的连接到$PS$内的$AXI$互联，唯一例外的是$ACP$接口，它直接连到$APU$里面的一致性控制单元$(SCU)$。
      + **通用AXI**——一条$32$位数据总线，适合$PL$和$PS$之间的中低速通信。接口是透传的不带缓冲。总共有四个通用接口：两个$PS$做主机，另两个$PL$做主机
      + **加速器一致性端口**——在$PL$和$APU$内的$SCU$之间的单个异步连接，总线宽度位64位，这个端口用来实现$APU\ cache$和$PL$的单元之间的一致性。$PL$是做主机的
      + **高性能端口**——四个高性能$AXI$接口，带有$FIFO$缓冲来提供"批量"读写操作，并支持$PL$和$PS$中的存储器单元 的高速率通信。数据宽度是32或64位，在所有四个接口中$PL$都是做主机的。
   
   3. EMIO接口——从$PS$出来，有几个连接可以经由$PL$到外部接口上，这被称作扩展的$MIO$，即$EMIO$.
   4. 其他PS-PL信号——跨越$PS-PL$边界的其他信号包括看门狗定时器、重启信号、中断和$DMA$接口信号。

5. 安全
   1. 安全引导——$Zynq-7000$芯片的引导方法只限于一种来源——芯片引导必须由处理器驱动。当芯片上电或重启的时候，$PS$的第一个核从外部存储器中引导，然后才会去配置$PL$.通过限制引导的方法为单一来源，就确保了就不可能在$PL$已经配置之后再有人工的方法来装在恶意的软件，同时在处理器已经初始化之后再也没有办法再装载恶意的映像到$PL$中去。
   2. 硬件支持——所有芯片都受益于内置的硬件安全$IP$，这个安全$IP$既可以是$PS$内的硬$IP$包，也可以是$PL$内的软$IP$。下面列出了$Zyqn$芯片和安全有关的一些特性：
      + $ARM\ TrustZone$支持
      + $AES-256$加密
      + 安全认证和启动
      + $HMAC$位流认证
      + $FSBL\ RAS-2048$认证
      + 禁止强硬回读
      + $JTAG$禁止/监视
      + $SEU$检查器

6. 在选择芯片时所涉及的因素

   | 分类         | 因素                                                         |
   | ------------ | ------------------------------------------------------------ |
   | 芯片能力     | 处理器性能<br />逻辑性能<br />存储器性能<br />支持高速算数<br />支持$I/O$和通信<br />安全特性和逻辑部分之间的带宽<br />处理器和逻辑部分之间的延迟 |
   | 商业因素     | 物料表<br />开发成本<br />集成(和隐形成本)<br />芯片供应的长期性和技术支持<br />质量和可靠性<br />实现现场升级的容易程度(和成本) |
   | 设计和开发   | 进入市场的时间<br />快速、便捷和可靠的设计流<br />集成的验证<br />与其他开发工具的集成<br />支持团队设计流<br />支持设计重用<br />支持工业标准的设计格式<br />支持所需的设计入口方法<br />文档和技术支持 |
   | 芯片物理特性 | 物理尺寸<br />功耗<br />易于集成和生产的PCB的复杂程度<br />可连接性<br />耐久性<br />是否对辐射敏感<br />支持的温度范围 |
   | 灵活性       | 可伸缩性（有更大或更小的芯片，而且只需要很小的甚至不需要工作就可以调整<br />可移植性(用标准格式设计可以移植到其他平台或从其他平台移植过来)<br />再编程能力(可以现场甚至在运行时刻动态改变功能)<br />易于划分(能在硬件和软件之间划分功能)<br />可扩展性(易于集成新的功能) |


7. 处理器$cache$——$cache$是一小块位于$CPU$和主存储器之间的存存储器。它具有比存储器低的访问时间，而且不能通过系统总线访问。
   +  在进一步讨论$cache$的不同级别之前，首先应该来介绍要用到的两种类型的存储器——动态$RAM(DRAM)$和静态$RAM(SRAM)$.
   + 动态$RAM(DRAM)$：是在计算机系统中最常见的存储器类型。$DRAM$芯片包括大量的存储单元，每个单元用电容保存1位的数据。每个存储单元还配有一个晶体管，它像一个开关一样让控制电路可以读或写这个电容的状态。由于电容和晶体管都极为微笑，单个$DRAM$芯片中可以放百万个独立的存储单元。由于电容会自己漏电，每个存储单元所保存一位的数据的状态最终会消失，除法这个电容上的电荷能周期性地被存储控制器所刷新。存储控制器通过读每个存储单元的 状态然后再写回去实现这个刷新。这正是动态$RAM$得名的由来。
   + 静态$RAM(SRAM)$：$SRAM$采用与 $DRAM$不同的技术来保存数据。$DRAM$的每一位是存储在电容中的，而$SRAM$用了锁存器来保存数据。每个存储单元需要4或6个锁存器来保存数据的一个位，因此比$DRAM$需要更多的芯片面积，从而导致它更贵。$SRAM$的好处是不需要刷新，因此比$DRAM$块很多。由于$SRAM$的高价，通常只用于高速、低容量的存储芯片中。
   +  $1级(L1)\ Cache$：是最小的$cache$存储器，典型的大小是8到128kb。它是以在处理器核心所在的硅片上的$SRAM$来实现的，因此具有与处理器相同的时钟速度。$L1\ cache$通常分成两个部分：数据$cache$和指令$cache$。 $L1\ cache$用来保存常用数据和指令的本地拷贝，使得处理器能瞬间访问它们。
   + $2级(L2)cache$：通常独立于处理器核心之外，但是离得非常近。它比$L1\ cache$大，通常在256到1024kb之间，但是访问速度较慢。$L2\ cache$是DRAM的形式，只有同一的一块区域（不像L1那样分成两块区域）。较大量的数据会不断地由主存储器读入$L2\ cache$，然后再馈送给$L1$.
   + $3级(L3)cache$：是再所有的处理器核心之间共享的，它也是$DRAM$的形式，是最大的$cache$存储器，通常具有$2MB$甚至更大的容量。

8. 执行周期：为了让一个保存在存储器中的程序能被处理器执行，程序必须经过一个执行周期。指令周期所用到的术语：

   + **机器码**——在写软件程序的时候，通常都是高级语言，这种语言易于被程序员所理解，而且是人可读的。这种形式的代码对于处理器系统是无意义的，必须被转换，或者说编译成处理器可以理解的形式。这最后的低级的能被处理器所阅读的输出结果就是机器码——一串和程序相关的、处理器能够解释和操作的二进制数据
   + **操作码**——一个操作码是一个运算编码，唯一地定义了要做的一个功能——一条机器码代表了一个处理器指令。一个处理器可以执行许多不同的运算，因此每条指令都被指定了唯一的数字编码。
   + **CPU指令集**——某个处理器的指令集是处理器能理解的命令的基本合集。它包含了每个操作码的定义和可以由处理器执行的本地命令

   1. **取指**：是指令执行周期的第一个阶段。具体流程是
      1. 程序计数器寄存器里有表示存储器里要执行的下一条执行的地址
      2. 这个值被传送给 存储器的地址寄存器，在那里，控制单元检查这个值并从寄存器中获得想用的指令。
      3. 那条指令于是就被保存在存储器缓冲寄存器中，然后再被传输给指令寄存器
      4. 控制单元改变程序计数器寄存器，让它的值符合下一条要执行的指令的地址

   2. **译码指令**：一旦指令被从寄存器中取出，下一步就是把指令变成处理器能够理解的形式。这就是译码阶段。在这个时刻，控制单元检查保存再指令寄存器里的指令。这个检查识别出操作码和所用的寻址方式，以及接下来需要执行什么动作来正确地执行这条指令。变成处理器能够理解的形式。这就是译码阶段。在这个时刻，控制单元检查保存再指令寄存器里的指令。这个检查识别出操作码和所用的寻址方式，以及接下来需要执行什么动作来正确地执行这条指令。
   
      主要有三种寻址方式：
   
      + **立即寻址**——这是不需要找数据的，因为所有要用到的数据都在指令的操作数部分里了。因此立即寻址是最快的，但是最不灵活的方式
      + **直接寻址**——指令的操作数部分包含了所需的数据的存储器地址。所需的数据必须从这个地址获得
      + **间接寻址**——指令的操作数包含了一个存储器地址。在这个地址上的存储器内容是一个指向所需数据地址的指针。因此间接寻址是最灵活的，但是由于要做两次数据查找，所以也是最慢的
   
   3.  **执行指令**：根据译码阶段所决定的操作码，在这个阶段可能做出各种不同的动作。总的来说有四大类动作：
      + 在处理器和存储器之间传输数据
      + 在处理器和$I/O$设备之间传输数据
      + 处理数据，比如用算数逻辑单元
      + 会改变后续操作的顺序的控制操作。这些可能是基于某个标志寄存器的值的条件操作
   
   一旦指令被执行了，下一条要处理的指令就被取了过来

9. 中断：硬件中断可以进一步被分类为以下几个类型：
   + **可屏蔽中断(IRQ)**——触发可屏蔽中断的事件源不总是重要的。程序员需要决定这个事件是否应该导致程序跳转到所需要处理的地方去。可能使用可屏蔽中断的设备包括定时器、比较器和$ADC$.
   +  **不可屏蔽中断(NMI)**——这些是不应该被忽视的中断，因此绝对比可屏蔽中断重要得多。需要NMI的时间包括上电、外部重启和严重的设备失效
   + **处理器间中断(IPI)**——在多处理器中，一个处理器可能需要中断另一个处理器的操作。在这种情况下，就会产生一个IPI.

10. 总线：实现了处理器和其他处理器及外围设备间的接口。   处理器、存储控制器和外围设备通过标准总线接口连接到总线上。

    1. 系统与外设总线：在较大型的嵌入式系统设计中，可能最好用多个总线来提供所有的处理器和外设之间的足够的通信带宽。**系统总线**、**外设总线**、**总线桥**
    2. 总线主机和从机
    3. 总线仲裁
    4. 存储器访问：一个嵌入式系统中存储控制器的访问方式能极大的影响整体的性能。即便使用了非常高效的存储器类型和存储控制器，系统的性能也会遭受到糟糕的存储访问控制的影响。重要的是系统以能最大化存储带宽的方式来构造和访问，同时保持最小的资源需求。
       + **可编程输入/输出**： 管理存储控制器和其他外设之间的数据移动手段之一，是让所有的数据传输都通过处理器，这样的存储传输叫做可编程I/O，让系统以最少的资源来处理存储传输。这个方法需要外设和处理器位于同一个总线上，处理器成为所有外设和存储器通信的中心点。如果外设和存储器之间的存储传输请求的数量很大，处理器就会花费大量时间来做存储传输，那么做其他计算的时间就少了。如果系统在可编程逻辑中实现大多数功能，那么可编程I/O是能用最少的资源管理存储事务的有效方法。不过，如果处理器需要从事大量其他计算，其他的方法也许更好
       + **直接访问控制(DMA)**：降低 处理器负担的一种办法是用直接存储器访问来做存储传输。用了这个方法，处理器像DMA控制器发出一个存储传输请求，然后DMA控制器将来做这个存储事务。这样当DMA控制器在做传输的时候，处理器就可以从事其他任务了。在这中情况下，DMA控制器既是总线主机也是总线从机。为了发起传输事务，DMA控制器必须得到以下数据：
         + 源地址——数据将要被读出的地址
         + 目的地址——数据应该被写入的地址
         + 传输长度——应被传输的字节数

    5. 总线带宽：总线带宽是总线上一定的单位时间内可以传输的总的数据量。总线带宽的值取决于两个因素：

       + 总线数据宽度——这是总线同时传输数据的物理的线路的数据量。32位独立数据线的总线可以同时传输32位的数据

       + 总线频率——这是总线操作的速度。这指的是每秒总线可以发送/接收的数据位的数量，是以赫兹位单位

         $Bus\ Bandwidth(Mbits/s)\ =\ Bus\ Width(bits)\ \times\ Bus\ Frequency(MHz)$ 

11. 存储器接口：所有$Zynq-7000$芯片上的存储器接口单元包括一个动态存储器控制器和几个静态存储器接口模块。动态存储器控制器可用于$DDR3$、$DDR3L$、$DDR2$、$LPDDR2$。静态存储器控制器支持一个$NAND$闪存接口、一个$Quad-SPI$闪存接口、一个并行数据总线和并行$NOR$闪存接口。

12. **AMBA Overview**

    | key  AMBA Specification                                      | AMBA2 | AMBA3    | AMBA4                   | AMBA5     |
    | ------------------------------------------------------------ | ----- | -------- | ----------------------- | --------- |
    | **CHI** Coherent Hub Interface<br />CHI is credited coherency protocol,<br />layer architecture for scalability |       |          |                         | CHI       |
    | **ACE** AXI coherency Extensions<br />ACE is superset of AXI-brings system-wide<br />coherency across multicore cluster |       |          | ACE+Lite                | ACE5+Lite |
    | **AXI** Advanced eXtensible Interface<br />AXI supports separate A/D phase,bursts,multiple<br />outstanding address,OoO responses |       | AXI3     | AXI4+Lite,<br />+Stream | AXI5      |
    | **AHB** Adv. High-performance Bus<br />AHB supports 64/128 bit,multimaster,<br />AHB-Lite for single masters | AHB   | AHB+Lite |                         | AHB5      |
    | **APB** Advanced Peripheral Bus<br />System bus for low b/w peripherals | APB2  | APB3     | APB4                    |           |

    **AMBA**(Advanced Microcontroller Bus Architecture)高级微处理器总线架构——定义了高性能嵌入式微控制器的通信标准，可以将RISC处理器集成在其他IP芯核和外设中，它是有效连接IP核的”数字胶“，并且是ARM复用策略的重要组件，它不是芯片与外设之间的接口，而是ARM内核与芯片 上其他元件进行通信的接口。主要包括：

    + AHB：高级高性能总线
    + ASB：高级系统总线
    + APB：高级外设总线
    + AXI：高级可扩展接口

    | 总线     | AXI                                                          | AHB                                                          | APB                                                  |
    | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
    | 总线宽度 | 8,16,32,64,128,256,512,1024                                  | 32,64,128,256                                                | 8,16,32                                              |
    | 地址宽度 | 32                                                           | 32                                                           | 32                                                   |
    | 通道特性 | 读写地址通道、读写数据通道均独立                             | 读写地址通道共用读写数据通道                                 | 读写地址通道共用读写数据通道<br />不支持读写并行操作 |
    | 体系结果 | 多主/从设备<br />仲裁机制                                    | 多主/从设备<br />仲裁机制                                    | 单主设备(桥)/多从设备<br />无仲裁                    |
    | 数据协议 | 支持流水/分裂传输<br />支持突发传输<br />支持乱序访问<br />字节/半字/字<br />大小端对齐<br />非对齐操作 | 支持流水/分裂传输<br />支持突发传输<br />支持乱序访问<br />字节/半字/字<br />大小端对齐<br />不支持非对齐操作 | 一次读/写传输占两个时钟周期<br />不支持突发传输      |
    | 传输方式 | 支持读写并行操作                                             | 不支持读写并行操作                                           | 不支持读写并行操作                                   |
    | 时许     | 同步                                                         | 同步                                                         | 同步                                                 |
    | 互联     | 多路                                                         | 多路                                                         | 无定义                                               |

    **AXI**是**ARM AMBA**单片机总线系列中的一个协议。**AMBA**协议是一个开放的片内互联规范标准，能在多主机设计中实现许多控制器和外围设备之间的连接和管理。

    **AXI** 协议特别体现了以下的关键特性：

    + 地址/控制阶段和数据阶段是分开的
    + 用字节闸来实现了非对其数据的传输
    + 只需发布起始地址就能做批量数据传输
    + 数据的读写通道是分离的，可以用来实现低成本的直接存储访问（DMA）
    + 可以指定多个需要处理的地址
    + 通信会话可以乱序完成
    + 为了实现时许收敛，可以方便地加入寄存器

    1. 各种AXI4：有三种AXI4接口类型，每一种都适合各自不同的应用类型：
       + AXI4——最高性能的接口，适合存储器映射的通信，支持每个地址阶段最高256个数据传输周期的批量传输
       + AXI4-Lite——这个接口的轻量级版本，用于存储器映射的单次数据通信绘画。这个版本的好处是简化了的接口占用较少的逻辑部分面积。这个版本不支持批量数据，因此只支持每次传输单个数据
       + AXI4-Stream——它没有地址阶段，因此不是存储器映射，能够做无限制的数据批量大小。为流式数据的传输定义了单个通道，不过支持无数量限制的批量传输。连接只能是从主机到从机，所有如果是需要双向传输的话，两个外围设备都必须是主机/从机兼容类型

    2. AXI架构

       1. 地址通道：读写的地址通道是分离的，能实现会话所需的所有地址和控制数据。这个数据决定了以下AXI协议机制的运作：
          + 批量，每个批次从1到16个数据的传输
          + 批量传输大小为8~1024位
          + 包裹、递增和非递增的批量传输
          + 在系统层面上的cache和缓冲
          + 独占的原子级操作切换或有锁的访问
          + 安全和特权的访问

       2. 写数据通道：写数据通道包括：
          + 一个8~1024位宽的数据总线
          + 每八位数据一个字节道闸，用来在数据总线中识别出有效的字节

       3. 读数据通道：包括一个相同范围的数据总线，另外还有一个读响应通道，用来表明一次读操作完成了
       4. 写响应通道：让从机可以在每个批次完成后，发出一个完成信号，从而向主机表明写操作完成了

### 后续实例和$:Linux$部分讲述太粗略，跳过，$The\ Zynq\ Book$ 完结

***

---

+++

## 高级FPGA设计：结构、实现和优化

1. 采用任意编码方式时，高级工具的优化程度常常不足以满足大多数设计约束的要求。本节主要讨论数字设计中三个主要物理特性的第一个：**速度**。
   + 速度有三种基本定义：**流量**、**时滞**和**时序**
     + **流量**定义为每个时钟周期处理的数据
     + **时滞**的一般度量是时间或时钟周期
     + **时序**定义为时序元件之间的逻辑延时，当一个设计没有“满足时序”时，意味着关键路径的延时，即触发器之间的最大延时比预定的时钟周期大，这些延时由组合逻辑延时、时钟到输出延时、布线延时、建立时间、时钟偏移等组成。时序的标准度量是时钟周期和频率

```verilog
//按照软件形式展开，递归
module a(
			output [7:0] XPower,
			output finished,
			input  [7:0] X,
			input  clk,start);
    
			reg [7:0] ncount;
			reg [7:0] XPower;
			
			assign finished = (ncount == 0);
			
			always @ (posedge clk)
			if(start) begin
				XPower <= X;
				ncount <= 2;
			end
			else if(!finished) begin
				ncount <= ncount - 1;
				XPower <= XPower * X;
			end
endmodule
//将上述改成流水线结构
module a(
			output reg [7:0] XPower,
			input clk,
			input [7:0] X);
			
			reg [7:0] XPower1,XPower2;
			reg [7:0] X1,X2;
			
			always @(posedge clk) 
			begin
				X1 <= X;
				XPower1 <= X;
				
				X2 <= X1;
				XPower2 <= XPower1 * X1;
				XPower <= XPower2 * X2;
			end
endmodule
//除去上述的流水线寄存器，使输入到输出的时序最小化
module a(
			output [7:0] XPower,
			input [7:0] X);
			
			reg [7:0] XPower1,XPower2;
			reg [7:0] X1,X2;
			
			assign XPower = XPower2 * X2;
			
			always @ * 
				begin
					X1 = X;
					XPower1 = X;
				end
			
			always @ *
				begin
					X2 = X1;
					XPower2 = XPower1 * X1;
				end
endmodule
```

2. **时序**：指的是一个设计的时钟速度。在设计中任何两个时序元件之间的最大延时将决定最大的时钟速度。时钟速度的概念比速度/面积权衡有更低层次的抽象，因为时钟速递一般不直接与这些拓扑有关，虽然在这些结构中的权衡将确实对时序有影响

   + 最高速度或最大频率可以直接按照著名的最大频率方程定义（不管时钟到时钟的抖动）：

     $F_{max}=\frac{1}{T_{clk-q}+T_{logic}+T_{routing}+T_{setup}-T_{skew}}$

     其中$F_{max}$是时钟可允许的最大频率，$T_{clk-q}$是时钟到达直至数据到达$Q$端的时间，$T_{logic}$是逻辑通过触发器之间的传播延时，$T_{routing}$是触发器之间的布线延时，$T_{setup}$是下一个时钟上升沿之前数据必须到达$D$端的最小时间(建立时间)，$T_{skew}$是启动触发器和捕捉触发器之间时钟的传播延时。

   + 一个乘法器和一个加法器组成的关键路径比最小时钟周期的要求大你，假设时滞要求不固定在一个时钟周期，添加额外的中间寄存器到此乘法器，使设计进一步流水线。

     ```verilog
     module a(
     			output [7:0] Y,
     			input [7:0] A,B,C,X,
     			input clk,
     			input validsample);
     			
     			reg [7:0] X1,X2,Y;
     			
     			always @ (posedge clk)
     				if(validsample)
     					begin
     						X1 <= X;
     						X2 <= X1;
     						Y <= A * X + B * X1 + C * X2;
     					end
     endmodule
     //假设上述FIR实现的结构不满足时序要求，则在乘法器和加法器之间添加一个流水线层次
     module a(
     			output [7:0] Y,
     			input [7:0] A,B,C,X,
     			input clk,
     			input validsample);
     			
     			reg [7:0] X1,X2,Y;
     			reg [7:0] pord1,pord2,pord3;
     			
     			always @ (posedge clk)
     				begin
     					if(validsample)
     						begin
     							X1 <= X;
     							X2 <= X1;
     							pord1 <= A * X;
     							pord2 <= B * X1;
     							pord3 <= C * X2;
     						end
     					Y <= pord1 + pord2 + pord3;
     				end 
     endmodule
     
     ```

     对于流水线乘法器是好的选择，因为计算 可以很容易分解成级。把乘法器和加法器分解成可以单独寄存的级，使附加流水线成为可能。

     **把关键路径分成两个更小延时的路径，添加寄存器层次改进时序**

   + 并行结构

     **把一个逻辑功能分成大量可以并行估计的更小的功能，减少路径延时为子结构的最长延时**

   + 展平逻辑结构

     **去除不需要的特权编码，展平逻辑结构，减少路径延时**

   + 寄存器平衡：平等地重新分布急窜起之间的逻辑，减少任何两个寄存器之间最坏条件的延时。
   + 重新安排路径：可以重新安排与关键路径组合的路径来改善时序，方法是关键路径的一些逻辑放置到接近目的寄存器

3. **面积** p23

